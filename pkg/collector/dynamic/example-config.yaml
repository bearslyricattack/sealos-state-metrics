# Example configuration for configurable dynamic collector

collectors:
  # Configurable dynamic collector - monitor any CRD without writing code
  # Enabled automatically if crds is configured
  dynamic:
    crds:
      # Example 1: Monitor KubeBlocks Cluster
      - name: kubeblocks-cluster
        gvr:
          group: apps.kubeblocks.io
          version: v1alpha1
          resource: clusters
        namespaces: []  # Empty = all namespaces
        resyncPeriod: 10m

        # Common labels extracted for all metrics
        commonLabels:
          cluster: metadata.name
          namespace: metadata.namespace

        # Metrics to expose
        metrics:
          # Info metric - always value=1, used to expose metadata
          - type: info
            name: info
            help: "Cluster information"
            labels:
              cluster_def: spec.clusterDefinitionRef
              cluster_version: spec.clusterVersionRef

          # State metric - emits ONLY the current state with value=1
          # No need to predefine states - only the actual current state is exposed
          # This is simpler and more efficient than emitting all possible states
          - type: state
            name: phase
            help: "Cluster phase"
            path: status.phase
            # Example: if status.phase = "Running", only one metric is emitted:
            #   kubeblocks_cluster_phase{cluster="...", namespace="...", state="Running"} 1

          # State count metric - aggregate count of resources in each state
          # This counts how many resources are in each state across all resources
          - type: state_count
            name: phase_count
            help: "Count of clusters by phase"
            path: status.phase
            # Example: if you have 3 Running, 2 Pending, 1 Failed clusters:
            #   kubeblocks_cluster_phase_count{state="Running"} 3
            #   kubeblocks_cluster_phase_count{state="Pending"} 2
            #   kubeblocks_cluster_phase_count{state="Failed"} 1

          # Gauge metric - direct numeric value
          - type: gauge
            name: observed_generation
            help: "Observed generation"
            path: status.observedGeneration

          # Map state metric - iterate over map and emit current state for each entry
          # Only emits the current state for each map key
          - type: map_state
            name: component_phase
            help: "Component phase"
            path: status.components
            valuePath: phase
            keyLabel: component
            # Example: if components = {mysql: {phase: "Running"}, redis: {phase: "Ready"}}
            # Two metrics are emitted:
            #   component_phase{..., component="mysql", state="Running"} 1
            #   component_phase{..., component="redis", state="Ready"} 1

          # Map gauge metric - iterate over map and emit numeric metrics
          - type: map_gauge
            name: component_pods_ready
            help: "Component pods ready status"
            path: status.components
            valuePath: podsReady
            keyLabel: component

          # Conditions metric - auto-parse Kubernetes-style conditions
          - type: conditions
            name: condition
            help: "Cluster conditions"
            path: status.conditions
            condition:
              typeField: type
              statusField: status
              reasonField: reason

      # Example 2: Monitor Sealos App CRD with auto-discovery
      - name: sealos-app
        gvr:
          group: apps.sealos.io
          version: v1
          resource: applications
        namespaces:
          - ns-user1
          - ns-user2
        resyncPeriod: 5m

        commonLabels:
          app: metadata.name
          namespace: metadata.namespace

        metrics:
          - type: info
            name: info
            help: "Application information"
            labels:
              app_type: spec.type
              version: spec.version

          # State metric - only current state is emitted
          - type: state
            name: status
            help: "Application status"
            path: status.phase

          - type: gauge
            name: replicas
            help: "Number of replicas"
            path: spec.replicas

          - type: conditions
            name: condition
            help: "Application conditions"
            path: status.conditions

      # Example 3: Monitor Crossplane Claim
      - name: crossplane-claim
        gvr:
          group: claim.crossplane.io
          version: v1alpha1
          resource: compositeclaims
        namespaces: []

        commonLabels:
          claim: metadata.name
          namespace: metadata.namespace

        metrics:
          - type: info
            name: info
            help: "Crossplane claim information"
            labels:
              composition: spec.compositionRef.name

          - type: state
            name: status
            help: "Claim status"
            path: status.phase

          - type: conditions
            name: condition
            help: "Claim conditions"
            path: status.conditions

# Environment variables can also be used:
# COLLECTORS_DYNAMIC_ENABLED=true
# COLLECTORS_DYNAMIC_CRDS_0_NAME=kubeblocks-cluster
# COLLECTORS_DYNAMIC_CRDS_0_GVR_GROUP=apps.kubeblocks.io
# etc.
